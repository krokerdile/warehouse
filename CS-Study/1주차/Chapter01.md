# 1장 컴퓨터 구조에 대한 첫 번째 이야기
# 01 시스템 프로그래밍의 이해와 접근

## 시스템 프로그래밍이란?

- 시스템 프로그램 ⇒ **“컴퓨터 시스템을 동작 시키는 프로그램”**
    - 컴퓨터를 동작시키기 위해서 필요한 프로그램
    - 동작 → 파일 복사, 파일 이동 등과 같은 동작들
    - 대표적인 시스템 프로그램 → 윈도우, 유닉스와 같은 운영체제 → 하드웨어를 모르는 사용자들이 컴퓨터를 쉽게 사용할 수 있도록 도와준다.
    - 운영체제는 시스템 프로그램의 범주에 속한다 → 운영체제 개발자 = 시스템 프로그래머
- 시스템 프로그램은 하드웨어를 사용할 수 있도록 도와주는 프로그램 → 그러면 하드웨어를 직접 컨트롤 할 수 있어야만 시스템 프로그래머가 될 수 있는 것 아닌가? → X
    - 어셈블리 언어나 C언어를 이용해 직접 하드웨어를 컨트롤 하는 개발자들도 시스템 프로그래머라고 한다.
    - 하지만 윈도우나 유닉스에서 제공하는 라이브러리를 이용해서 개발을 하면 각 운영체제의 시스템 프로그래머라고 볼 수 있다. → 윈도우/유닉스 시스템 프로그래머
- 윈도우 시스템 프로그래머가 되려면? → 윈도우가 제공하는 시스템 함수들을 이해해야 한다 → 운영체제에 대한 최소한의 지식이 필요하다 → 이를 이해하기 위해서는 컴퓨터 구조에 대한 이해가 필요하다

# 02 컴퓨터 하드웨어의 구성

## 컴퓨터 시스템의 주요 구성요소

- CPU ↔ 캐쉬(Cache) ↔ 메인메모리(Main Memory) ↔ 하드 디스크(Hard Disk)

![간단하게 하드웨어 구성을 간략해 해둔 그림](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/d208f749-52ea-41da-ae2b-01aa892b964b/Untitled.png)

간단하게 하드웨어 구성을 간략해 해둔 그림

## CPU(Central Processing Unit)

- 흔히 얘기하는 **중앙처리장치**
- 기본적으로 연산을 담당하고 있다 + 컴퓨터 프로그램의 실행에서 핵심적인 역할 담당 → 컴퓨터의 머리

## 메인 메모리(Main Memory)

- 램(RAM)이라는 저장 장치로 구성됨
- 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역
- 프로그램 실행을 위해 존재하는 메모리

## 입*출력 버스(Input/Output Bus)

- 컴퓨터를 구성하는 구성요소 사이에서 데이터를 주고 받기 위해 사용되는 경로 → 고속도로 같은
- 주고 받는 데이터의 종류와 역할에 따라서 어드레스(Address)/데이터(Data)/컨트롤(Control) 버스로 구분
- 하드 디스크, 메인 메모리, CPU 등의 구성 요소에 대해서 버스 시스템을 기반으로 데이터를 옮기는 길을 제공

# CPU에 대한 이해

![스크린샷 2024-03-02 오후 1.24.26.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/cad4be63-6f2c-4e71-9b96-792a30f698b8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-03-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.24.26.png)

## ALU(Arithmetic Logic Unit)

- 프로그램이 실행 되는 곳 → CPU, 그렇다면 연산은 어디서 일어나는가? CPU안의 ALU에서 담당
- ALU가 처리하는 기본적인 연산은 크게 두 가지로 나뉜다.
    - 덧셈과 뺄셈과 같은 산술 연산
    - AND나 OR와 같은 논리 연산
- 엄청나게 복잡한 연산도 CPU에서는 위의 두가지 연산으로 이뤄진다.

## 컨트롤 유닛(Control Unit)

- 프로그래머가 작성한 프로그램을 컴파일 하면 실행 파일이 생성된다. → 해당 파일에는 CPU에게 일을 시키기 위한 명령어들이 저장되어져 있다. → **해당 명령어가 CPU 내부로 들어가야 일을 시킬 수 있다.**
- 명령어가 만약 CPU로 내부로 들어오고 해당 연산을 담당하는 ALU에게 명령어가 전달 되었다고 가정하자
    
    → 32비트 명령어가 들어 왔다(10011010 … 10010011) → ALU가 이 명령어를 이해할 수 있을까? → **연산만 할 줄 아는 친구이기 때문에 다른 누군가가 이 명령어를 해석해 줘야 한다.**
    
    → 이걸 해주는 친구가 바로 컨트롤 유닛
    
- 컨트롤 유닛이 하는 일 ⇒ **“CPU가 처리해야 할 명령어들을 해석하는 것”**

## CPU 내부에 존재하는 레지스터들

- 명령어가 들어올 대 해당 명령어의 피연산자들이 함께 오고 해당 피연자들을 저장해두고 사용하기 위한 공간이 필요하다. → 조그마한 메모리 공간이 필요하다 → 레지스터
- 레지스터
    - 임시적으로 데이터를 저장하기 위한 조그마한 메모리 공간
    - 2진 데이터(Binary Data) 저장을 위한 저장 장치
    - CPU에 따라서 16비트, 32비트, 64비트 정도의 데이터를 저장 한다.
    - CPU의 종류에 따라서 그 개수와 형태가 다양하다
    - 각각의 용도가 정해져 있는 경우가 일반적이다

## 버스 인터페이스(Bus Interface)

- CPU, 하드디스크, RAM, 사운드 카드, 그래픽 카드 등과 같은 장비들이 독립적으로 동작하는 것이 아니라 데이터를 주고 받으면서 동작한다.
- 해당 장비들이 서로 데이터를 주고 받기 위해서는 어떠한 매개체가 있어야 할 것 →  I/O 버스(BUs)
- CPU가 I/O 버스에 접근이 가능하고 이를 통해 데이터를 전송 혹은 입력 받는다 → 하지만 비행기도 이용방법을 알아야 탑승할 수 있는 것 처럼 CPU 내에도 I/O 버스의 통신방식을 이해하고 있는 무엇인가가 있다.
    
    → 이 역할을 해주는 것이 바로 버스 인터페이스(Bus Interface)이다.
    
    - 버스가 어떻게 데이터를 전송하는 지 그에 대한 프로토콜 혹은 통신방식을 알고 있는 녀석이다

## 클럭 신호(Clock pulse)

- CPU를 구성하는 요소는 아님, 하지만 **CPU를 구성하는 요소에 제공되어야 하는 신호로 중요한 의미를 담음**
- 타이밍(Timing)을 제공하기 위해 필요한 것
- 1.6MZ → 1초 당 1,600,000번의 클럭을 클럭발생기가 발생시킨다 → 매 클럭이 발생할 때에 맞춰서 CPU가 일을 하게 된다. → 클럭 속도가 높을 수록 초당 처리하는 명령어의 개수가 많이지므로 성능이 좋아질 수 있다.
- 클럭 신호를 안따르고 그냥 일을 하면 되지 않나? → 컴퓨터 시스템은 여러 장비로 이뤄져 있고, 해당 장비들의 동기화를 필요로 하기 때문에 클럭 신호가 필수적이라고 볼 수 있다.

# 04 프로그램의 실행과정

## 위대한 수학자 폰 노이만

- 초창기 컴퓨터는 임의의 연산을 하고자 할 때마다 여러 명의 엔지니어가 붙어서 진공관 회로의 스위치를 변경해주어야 됐다.
- 폰 노이만은 보다 개선된 형태의 컴퓨터를 고민하게 되었고 아래와 같은 구조의 컴퓨터를 생각해낸다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/a3d69d68-0d6f-4899-b807-94efc9137f6b/Untitled.png)

> **CPU ↔ 메모리 ← Load ← 프로그램**
> 
- 위의 그림은 위와 같이 돌아가는 느낌인데, 중요하게 봐야 할 요소는 메모리와 프로그램이다.
- 기존의 프로그램은 단순히 진공관 회로의 스위치 구성을 의미하는 것이었지만, 폰 노이만은 프로그램이 컴퓨터 내부에 저장되는 구조를 생각해낸 것이다.
- 폰 노이만의 컴퓨터 구조 → **“프로그램이라는 것이 존재하고, 이 프로그램은 컴퓨터 내부에 저장되어 순차적으로 실행되어야 한다.” → 프로그램이 컴퓨터 내부에 저장 → “Stored Program Concept”이라고도 불림**
- 폰 노이만 아키텍처라는 컴퓨터 구조를 기반으로 한 최초의 컴퓨터가 EDSAC이라는 이름으로 탄생하게 된다

## 프로그램의 실행과정

> 실행 파일의 생성 단계 : **전처리기 → 컴파일러 → 어셈블러 → 링커**
> 
1. 전처리기에 의한 치환작업
    - 전처리기는 #include, #define과 같은 #으로 시작하는 지시자의 지시에 따라서 소스코드를 적절히 변경하는 작업을 한다.
2. 컴파일러에 의한 번역
    - 1단계에 의해 변경된 소스코드는 여전히 C언어로 구성되어 있다. → 컴파일러에 의해 어셈블리로 번역된다
    - 어셈블리 코드란? → CPU에 일을 시키기 위한 명령어를 조합해서 만들어진 프로그램 코드
    - 컴파일러가 없다면 직접 C언어를 어셈블러 언어에 맞게 작성해야 한다.
3. 어셈블러에 의한 바이너리 코드 생성
    - 0과 1로만 구성되어지는 코드
    - 어셈블리 코드는 컴퓨터에 의해 실행되기에 앞서 바이너리 코드로 번역되어야 한다
    - 덧셈 0011 이라면 CPU에 0011이 들어가면 덧셈이 실행 되는 방식이다. 하지만 바이너리로 계속해서 작성을 한다면 불편하기 때문에 이를 “ADD”와 같이 이름을 붙여 참조하여 사용할 수 있게 해주었다
        
        → 이러한 방식의 프로그래밍이 어셈블리 프로그래밍이다. 
        
        → 이를 반대로 바이너리 코드로 바꿔주는 것이 어셈블러이다. 
        
    1. 링커에 의한 연결과 결합
        - 링커는 간단히 얘기하면 프로그램 내에서 참조하는 함수나 라이브러리들을 하나로 묶는 작업을 한다
        - 묶어주는 과정이 끝나면 실제로 실행 가능한 실행파일이 생성되어진다.
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/e3ff8565-4a40-4608-a05f-f5ded4dca779/Untitled.png)
        
        - 위의 단계는 다음과 같이 실행 되어진다.
            1. Fetch: 메모리 상에 존재하는 명령어를 CPU로 가져오는 작업
            2. Decode: 가져다 놓은 명령어를 CPU가 해석하는 단계
            3. Execution: 해석된 명령어의 명령대로 CPU가 실행하는 단계
    
    # 05 하드웨어 구성의 재접근
    
    ![폰 노이만의 컴퓨터 구조에 맞게 위의 단계를 적용한것 ](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/5ad59f12-64fd-4654-81fc-c823eca9fd8a/Untitled.jpeg)
    
    폰 노이만의 컴퓨터 구조에 맞게 위의 단계를 적용한것 
    
    - 위의 그림을 보고 우리는 다음과 같은 질문에 대답할 수 있어야 한다.
        1. 명령어 실행을 위해 제일 먼저 하는 일이 Fetch인데 어떠한 이동 경로를 통해서 명령어와 Fetch가 진행 되는 것인가?
            
            → 아래에서 좀 더 자세하게 
            
        2. 명령어를 CPU 안에 가져다 놓을 때 어디에 저장 하는 것인가?
            
            → 레지스터
            
        3. CPU 안에 가져 다 놓은 명령어는 Decode 단계에서 해석 되는데 이는 CPU안에 존재하는 누구에 의해서 진행 되는 것인가?
            
            → 컨트롤 유닛
            
        4. 마지막 단계인 Excution은 누구에 의해서 진행되는가?
            
            → ALU
            
    
    ## 데이터 이동의 기반이 되는 버스(BUS) 시스템
    
    - 데이터를 이동하는 데 있어서 사용되는 전송 경로를 가리켜 버스 시스템(Bus System)이라고 한다.
    - 버스 시스템은 데이터의 종류에 따라 어드레스, 데이터, 컨트롤 버스 3가지로 구분한다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0483f3fb-e84e-43e6-b3c7-d93e74749b98/09fa05a8-7001-43a1-945c-8c52afcab5d2/Untitled.png)
    
    - I/O 버스를 통해서 다양한 주변 장치들이 연결되어져 있다 → I/O 버스는 여러 장치들이 데이터를 주고 받기 위한 통로의 역할을 한다
    - 각각의 버스 용도
        - 데이터 버스(Data Bus): 데이터를 이동하기 위해 필요한 버스. 데이터는 명령어가 될 수도 있고 연산에 필요한 피연산자(Operand)가 될 수도 있다.
        - 어드레스 버스(Address Bus): 주소값을 이동하기 위해 필요한 버스. 메모리가 데이터를 읽을 때 해당 데이터가 있는 주소를 먼저 받고 넘어가기 위한 느낌으로 생각하면 됨
        - 컨트롤 버스(Control Bus): CPU가 원하는 바를 메모리에 전달할 대 사용한다. CPU와 메모리가 특별한 사인(Sign)을 주고 받는 용도
            - CPU에서 메모리로 부터 데이터를 가져오는 경우, 반대로 메모리에 데이터를 저장하는 경우 데이터를 주고 받을 것인지에 대한 적절한 사인이 오고 가야 한다.
            - 데이터 보내/간다 + 0X1200번지로 → 데이터를 주고받을 지에 대해서 + 어느 주소에 저장된 데이터를 다룰 것인지